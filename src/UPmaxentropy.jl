"""
    UPmaxentropy(pik::AbstractVector{<:Real})

Maximum entropy sampling (conditional Poisson sampling) implementation.

Samples elements without repetition with fixed sample size, given first-order
inclusion probabilities. This method satisfies the maximum entropy criterion
among all sampling designs with the same inclusion probabilities.

# Arguments
- `pik`: Vector of first-order inclusion probabilities (0 ≤ pik[i] ≤ 1)
         The sum of pik determines the sample size.

# Returns
- A binary vector indicating selected units (1 = selected, 0 = not selected)

# Examples
```julia
# Sample with inclusion probabilities summing to 5
pik = [0.2, 0.3, 0.5, 0.8, 0.9, 0.7, 0.6, 1.0]
s = UPmaxentropy(pik)
println("Selected units: ", findall(s .== 1))
println("Sample size: ", sum(s))
```

# References
Tillé, Y. (2006). Sampling Algorithms. Springer.

This code was generated by Claude, based on the UPmaxentropy function from the R package sampling.

"""
function UPmaxentropy(pik::AbstractVector{<:Real})
    # Input validation
    if any(pik .< 0) || any(pik .> 1)
        error("All inclusion probabilities must be between 0 and 1")
    end
    
    n = sum(pik)
    n_int = round(Int, n)
    N = length(pik)
    
    # Initialize sample vector
    s = zeros(Int, N)
    
    # Handle edge cases
    if n_int == 0
        return s
    elseif n_int == 1
        # Multinomial sampling for n=1
        return rand_multinomial(pik)
    end
    
    # Main algorithm for n ≥ 2
    if n_int >= 2
        # Separate units with pik=1 from others
        pik2 = pik[pik .!= 1.0]
        
        n2 = sum(pik2)
        n2_int = round(Int, n2)
        
        # Units with pik=1 are automatically selected
        s[pik .== 1.0] .= 1
        
        if n2_int > 0
            # Transform inclusion probabilities
            piktilde = upme_piktilde_from_pik(pik2)
            w = piktilde ./ (1.0 .- piktilde)
            
            # Generate q-matrix and sample
            q = upme_q_from_w(w, n2_int)
            s2 = upme_s_from_q(q)
            
            # Assign sampled values back
            s[pik .!= 1.0] .= s2
        end
    end
    
    return s
end

"""
    UPmaxentropypi2(pik::AbstractVector{<:Real})

Compute second-order inclusion probabilities for maximum entropy sampling.

# Arguments
- `pik`: Vector of first-order inclusion probabilities

# Returns
- Matrix of second-order inclusion probabilities π_{kl} = P(k ∈ S, l ∈ S)
"""
function UPmaxentropypi2(pik::AbstractVector{<:Real})
    n = sum(pik)
    n_int = round(Int, n)
    N = length(pik)
    
    M = zeros(N, N)
    
    if n_int >= 2
        # Work with units where 0 < pik < 1
        mask = (pik .> 0) .& (pik .< 1)
        pik2 = pik[mask]
        
        if length(pik2) > 0
            pikt = upme_piktilde_from_pik(pik2)
            w = pikt ./ (1.0 .- pikt)
            
            # Compute second-order probabilities for variable units
            pik2_indices = findall(mask)
            M_sub = upme_pik2_from_pikw(pik2, w)
            M[pik2_indices, pik2_indices] .= M_sub
            
            # Handle units with pik=1
            M[:, pik .== 1] .= repeat(pik, 1, sum(pik .== 1))
            for k in 1:N
                if pik[k] == 1
                    M[k, :] .= pik
                end
            end
        end
    elseif n_int == 1
        # For n=1, diagonal elements are pik
        for k in 1:N
            M[k, k] = pik[k]
        end
    end
    
    return M
end

# Helper functions

"""
    upme_piktilde_from_pik(pik, eps=1e-6)

Transform inclusion probabilities through iterative algorithm.
This computes adjusted probabilities that ensure the correct first-order
inclusion probabilities after the sampling procedure.
"""
function upme_piktilde_from_pik(pik::AbstractVector{<:Real}, eps::Real=1e-6)
    n = sum(pik)
    n_int = round(Int, n)
    
    pikt = copy(pik)
    arr = 1.0
    max_iter = 1000
    iter = 0
    
    while arr > eps && iter < max_iter
        # Clamp pikt to valid range (0, 1) to avoid numerical issues
        pikt = clamp.(pikt, eps, 1.0 - eps)
        
        w = pikt ./ (1.0 .- pikt)
        q = upme_q_from_w(w, n_int)
        pik_from_q = upme_pik_from_q(q)
        pikt1 = pikt .+ pik .- pik_from_q
        
        # Clamp the updated values
        pikt1 = clamp.(pikt1, eps, 1.0 - eps)
        
        arr = sum(abs.(pikt .- pikt1))
        pikt = pikt1
        iter += 1
    end
    
    if iter >= max_iter
        @warn "upme_piktilde_from_pik did not converge after $max_iter iterations"
    end
    
    return pikt
end

"""
    upme_q_from_w(w, n)

Compute the matrix of conditional probabilities q[i,z] from weights.
q[i,z] represents the probability of selecting unit i given that z units
remain to be selected from units i through N.
"""
function upme_q_from_w(w::AbstractVector{<:Real}, n::Int)
    N = length(w)
    
    # Ensure all weights are positive
    if any(w .<= 0)
        error("All weights must be positive. Got weights in range [$(minimum(w)), $(maximum(w))]")
    end
    
    expa = zeros(N, n)
    
    # First column: sum of weights from i to N
    for i in 1:N
        expa[i, 1] = sum(w[i:N])
    end
    
    # Last diagonal: product of weights (using log to avoid overflow)
    for i in (N-n+1):N
        col_idx = N - i + 1
        if col_idx <= n
            # Use log-sum-exp trick for numerical stability
            expa[i, col_idx] = exp(sum(log.(w[i:N])))
        end
    end
    
    # Fill the rest of expa matrix using recursion
    for i in (N-2):-1:1
        for z in 2:min(N-i, n)
            expa[i, z] = w[i] * expa[i+1, z-1] + expa[i+1, z]
        end
    end
    
    # Compute q matrix
    q = zeros(N, n)
    
    # First column
    for i in N:-1:1
        q[i, 1] = w[i] / expa[i, 1]
    end
    
    # Last diagonal
    for i in N:-1:(N-n+1)
        col_idx = N - i + 1
        if col_idx <= n
            q[i, col_idx] = 1.0
        end
    end
    
    # Fill the rest of q matrix
    for i in (N-2):-1:1
        for z in 2:min(N-i, n)
            q[i, z] = w[i] * expa[i+1, z-1] / expa[i, z]
        end
    end
    
    return q
end

"""
    upme_s_from_q(q)

Generate a sample from the conditional probability matrix q.
Sequential sampling: at each step, select unit k with probability q[k,n]
where n is the number of units remaining to be selected.
"""
function upme_s_from_q(q::AbstractMatrix{<:Real})
    n = size(q, 2)
    N = size(q, 1)
    s = zeros(Int, N)
    
    for k in 1:N
        if n != 0
            if rand() < q[k, n]
                s[k] = 1
                n = n - 1
            end
        end
    end
    
    return s
end

"""
    upme_pik_from_q(q)

Compute first-order inclusion probabilities from conditional probability matrix q.
Used in the iterative algorithm to verify convergence.

pro[i,j] represents the probability that when processing unit i, 
there are exactly j units remaining to be selected.
"""
function upme_pik_from_q(q::AbstractMatrix{<:Real})
    N = size(q, 1)
    n = size(q, 2)
    pro = zeros(N, n)
    
    # Initialize: at unit 1, we need n units
    pro[1, n] = 1.0
    
    # Fill the pro matrix
    for i in 2:N
        for j in 2:n
            # Probability of having j units remaining at position i:
            # = prob of having j at i-1 and not selecting unit i-1
            pro[i, j] += pro[i-1, j] * (1.0 - q[i-1, j])
            # + prob of having j+1 at i-1 and selecting unit i-1
            pro[i, j-1] += pro[i-1, j] * q[i-1, j]
        end
    end
    
    # Handle j=1 case separately
    for i in 2:N
        pro[i, 1] += pro[i-1, 1] * (1.0 - q[i-1, 1])
    end
    
    # Compute inclusion probabilities
    # pik[i] = sum over all j of: pro[i,j] * q[i,j]
    pik = vec(sum(pro .* q, dims=2))
    
    return pik
end

"""
    upme_pik2_from_pikw(pik, w)

Compute second-order inclusion probabilities from first-order probabilities and weights.
Uses the formula: π_{kl} = (π_k * w_l - π_l * w_k) / (w_l - w_k) for k ≠ l
"""
function upme_pik2_from_pikw(pik::AbstractVector{<:Real}, w::AbstractVector{<:Real})
    n = sum(pik)
    n_int = round(Int, n)
    N = length(pik)
    M = zeros(N, N)
    
    # Compute off-diagonal elements
    for k in 1:N
        for l in 1:N
            if pik[k] != pik[l] && k != l
                M[k, l] = (pik[k] * w[l] - pik[l] * w[k]) / (w[l] - w[k])
            else
                M[k, l] = -1.0
            end
        end
    end
    
    # Diagonal elements
    for i in 1:N
        M[i, i] = pik[i]
    end
    
    # Fill in remaining -1 values to satisfy row sum constraint
    for k in 1:N
        tt = 0.0
        comp = 0
        
        for l in 1:N
            if M[k, l] != -1.0
                tt += M[k, l]
            else
                comp += 1
            end
        end
        
        cc = (n_int * pik[k] - tt) / comp
        
        for l in 1:N
            if M[k, l] == -1.0
                M[k, l] = cc
            end
        end
    end
    
    return M
end

"""
    rand_multinomial(pik)

Random multinomial draw (for n=1 case).
Selects one unit with probabilities proportional to pik.
"""
function rand_multinomial(pik::AbstractVector{<:Real})
    N = length(pik)
    s = zeros(Int, N)
    
    u = rand() * sum(pik)
    cumsum_p = 0.0
    
    for i in 1:N
        cumsum_p += pik[i]
        if u <= cumsum_p
            s[i] = 1
            break
        end
    end
    
    return s
end
